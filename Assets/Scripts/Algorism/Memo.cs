using Unity.Android.Gradle;
using UnityEngine;
using UnityEngine.UIElements;
using static UnityEngine.Rendering.ProbeAdjustmentVolume;

public class Memo : MonoBehaviour
{

    /*
✅ 속도 기준 최적화 순서(빠른 것부터 느린 것까지):
    
    이진 탐색(Binary Search)

        ✅ O(log n)

        🔹정렬된 데이터에서만 가능하지만 가장 빠름

        🔹배열이나 리스트에 사용할 때 최고 성능

    이진 탐색 트리(BST: Binary Search Tree)

        ✅ O(log n) (균형 잡힌 경우)

        ⚠️하지만 트리가 한쪽으로 치우치면 최악의 경우 O(n)

        🔹AVL, Red-Black Tree 등으로 균형 잡으면 성능 보장 가능

    다익스트라 알고리즘(Dijkstra's Algorithm)

        ✅ O(E + V log V) (우선순위 큐 사용 시)

        🔹최단 경로 탐색에 특화, 큼직한 맵에서도 성능 괜찮음

        🔹A* 알고리즘보다 느릴 수도 있지만 무난한 최단경로 탐색 성능

    너비 우선 탐색(BFS)

        ✅ O(V + E)

        🔹Queue 기반, 가까운 노드부터 탐색

        🔹대부분의 길찾기(퍼즐, 길찾기 AI)에 자주 사용

        🔹메모리 소모가 DFS보다 많지만 경로 탐색 성능이 뛰어남

    깊이 우선 탐색(DFS)

        ✅ O(V + E)

        🔹Stack 기반, 깊게 파고드는 방식

        🔹경로 찾기엔 좋지 않지만, 탐색/검사/백트래킹엔 유용

    순차 탐색(Linear Search)

        ❌ O(n)

        🔹가장 느림.데이터가 많을수록 비효율적

        🔹간단한 상황에만 사용 추천

📌 정리: 유니티에서 최적화된 순서 (빠른 것 → 느린 것)
순위 알고리즘    시간 복잡도  유니티에서 주 용도
①	이진 탐색   O(log n)    정렬된 데이터에서 빠른 검색
②	이진 탐색 트리(BST)  O(log n) 평균 동적 삽입/삭제가 많은 경우
③	다익스트라 알고리즘  O(E + V log V)  경로 찾기 AI, 맵 길찾기 등
④	너비 우선 탐색(BFS)  O(V + E)    퍼즐, 길찾기, 최단 거리, AI
⑤	깊이 우선 탐색(DFS)  O(V + E)    미로 탐색, 경로 확인, 백트래킹
⑥	순차 탐색   O(n)    소규모 데이터, 테스트용만 적합

   




📊 정렬 알고리즘 비교 요약표

    목적                     추천 정렬
    가장 간단한 구현        선택 정렬, 삽입 정렬
    이미 정렬된 배열        개선형 버블 정렬, 삽입 정렬
    항상 안정된 성능        합병 정렬
    실전에서 가장 빠름      퀵 정렬(pivot 전략 주의)
    메모리 적게             삽입/퀵/선택 정렬(제자리 정렬)

🧩 알고리즘 선택 기준 예시
    데이터가 거의 정렬됨 → 삽입 정렬, 개선형 버블 정렬

    메모리가 중요함 → 퀵 정렬, 삽입 정렬

    안정 정렬 필요(순서 유지) → 합병 정렬, 삽입 정렬

    빠른 정렬이 목적 → 퀵 정렬, 합병 정렬

     */
}
